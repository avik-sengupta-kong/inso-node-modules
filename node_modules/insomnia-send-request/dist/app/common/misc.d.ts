/// <reference types="node" />
import { Readable, Writable } from 'stream';
interface Header {
    name: string;
    value: string;
}
interface Parameter {
    name: string;
    value: string;
}
export declare function filterParameters<T extends Parameter>(parameters: T[], name: string): T[];
export declare function filterHeaders<T extends Header>(headers: T[], name?: string): T[];
export declare function hasContentTypeHeader<T extends Header>(headers: T[]): boolean;
export declare function hasContentLengthHeader<T extends Header>(headers: T[]): boolean;
export declare function hasAuthHeader<T extends Header>(headers: T[]): boolean;
export declare function hasAcceptHeader<T extends Header>(headers: T[]): boolean;
export declare function hasUserAgentHeader<T extends Header>(headers: T[]): boolean;
export declare function hasAcceptEncodingHeader<T extends Header>(headers: T[]): boolean;
export declare function getSetCookieHeaders<T extends Header>(headers: T[]): T[];
export declare function getLocationHeader<T extends Header>(headers: T[]): T | null;
export declare function getContentTypeHeader<T extends Header>(headers: T[]): T | null;
export declare function getMethodOverrideHeader<T extends Header>(headers: T[]): T | null;
export declare function getHostHeader<T extends Header>(headers: T[]): T | null;
export declare function getContentDispositionHeader<T extends Header>(headers: T[]): T | null;
export declare function getContentLengthHeader<T extends Header>(headers: T[]): T | null;
/**
 * Generate an ID of the format "<MODEL_NAME>_<TIMESTAMP><RANDOM>"
 * @param prefix
 * @returns {string}
 */
export declare function generateId(prefix?: string): string;
export declare function delay(milliseconds?: number): Promise<void>;
export declare function removeVowels(str: string): string;
export declare function formatMethodName(method: string): string;
export declare function keyedDebounce<T extends Function>(callback: T, millis?: number): T;
export declare function debounce<T extends Function>(callback: T, milliseconds?: number): T;
export declare function describeByteSize(bytes: number, long?: boolean): string;
export declare function nullFn(): void;
export declare function preventDefault(e: Event): void;
export declare function fnOrString(v: string | ((...args: any[]) => any), ...args: any[]): any;
export declare function compressObject(obj: any): string;
export declare function decompressObject(input: string | null): any;
export declare function resolveHomePath(p: string): string;
export declare function jsonParseOr(str: string, fallback: any): any;
export declare function escapeHTML(unsafeText: string): string;
/**
 * Escape a dynamic string for use inside of a regular expression
 * @param str - string to escape
 * @returns {string} escaped string
 */
export declare function escapeRegex(str: string): string;
export declare function fuzzyMatch(searchString: string, text: string, options?: {
    splitSpace?: boolean;
    loose?: boolean;
}): null | {
    score: number;
    indexes: number[];
};
export declare function fuzzyMatchAll(searchString: string, allText: string[], options?: {
    splitSpace?: boolean;
    loose?: boolean;
}): {
    score: number;
    indexes: number[];
    target: string;
} | null;
export declare function waitForStreamToFinish(stream: Readable | Writable): Promise<void>;
export declare function chunkArray<T>(arr: T[], chunkSize: number): T[][];
export declare function pluralize(text: string): string;
export declare function diffPatchObj(baseObj: {}, patchObj: {}, deep?: boolean): any;
export declare function isObject(obj: unknown): boolean;
/**
  Finds epoch's digit count and converts it to make it exactly 13 digits.
  Which is the epoch millisecond representation.
*/
export declare function convertEpochToMilliseconds(epoch: number): number;
export declare function snapNumberToLimits(value: number, min?: number, max?: number): number | undefined;
export declare function isNotNullOrUndefined(obj: unknown): boolean;
export {};
//# sourceMappingURL=misc.d.ts.map