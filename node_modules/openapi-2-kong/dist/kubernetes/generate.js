"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateServicePath = exports.generateServicePort = exports.generateTLS = exports.generateServiceName = exports.generateIngressRule = exports.generateMetadataAnnotations = exports.getSpecName = exports.generateKongForKubernetesConfigFromSpec = void 0;
const common_1 = require("../common");
const url_join_1 = __importDefault(require("url-join"));
const plugins_1 = require("./plugins");
const variables_1 = require("./variables");
const generateKongForKubernetesConfigFromSpec = (api) => {
    const specName = exports.getSpecName(api);
    // Extract global, server, and path plugins upfront
    const plugins = plugins_1.getPlugins(api);
    // Initialize document collections
    const ingressDocuments = [];
    const methodsThatNeedKongIngressDocuments = new Set();
    let _iterator = 0;
    const increment = () => _iterator++;
    plugins.servers.forEach((serverPlugin, serverIndex) => {
        plugins.paths.forEach(pathPlugin => {
            pathPlugin.operations.forEach(operation => {
                // Prioritize plugins for doc
                const pluginsForDoc = plugins_1.prioritizePlugins(plugins.global, serverPlugin.plugins, pathPlugin.plugins, operation.plugins);
                // Identify custom annotations
                const annotations = {
                    pluginNames: pluginsForDoc.map(plugin => plugin.metadata.name),
                };
                const { method } = operation;
                if (method) {
                    annotations.overrideName = common_1.getMethodAnnotationName(method);
                    methodsThatNeedKongIngressDocuments.add(method);
                }
                const metadata = generateMetadata(api, annotations, increment, specName);
                const tls = exports.generateTLS(serverPlugin.server);
                const rule = exports.generateIngressRule(serverIndex, serverPlugin.server, specName, [pathPlugin.path]);
                const doc = {
                    apiVersion: 'extensions/v1beta1',
                    kind: 'Ingress',
                    metadata,
                    spec: {
                        ...(tls ? { tls } : {}),
                        rules: [rule],
                    },
                };
                ingressDocuments.push(doc);
            });
        });
    });
    const methodDocuments = Array.from(methodsThatNeedKongIngressDocuments).map(generateK8sMethodDocuments);
    const pluginDocuments = plugins_1.flattenPluginDocuments(plugins);
    const result = {
        type: 'kong-for-kubernetes',
        label: 'Kong for Kubernetes',
        documents: [
            ...methodDocuments,
            ...pluginDocuments,
            ...ingressDocuments,
        ],
        warnings: [],
    };
    return result;
};
exports.generateKongForKubernetesConfigFromSpec = generateKongForKubernetesConfigFromSpec;
const generateK8sMethodDocuments = (method) => ({
    apiVersion: 'configuration.konghq.com/v1',
    kind: 'KongIngress',
    metadata: {
        name: common_1.getMethodAnnotationName(method),
    },
    route: {
        methods: [method],
    },
});
const generateMetadata = (api, customAnnotations, increment, specName) => ({
    name: `${specName}-${increment()}`,
    annotations: exports.generateMetadataAnnotations(api, customAnnotations),
});
const getSpecName = (api) => common_1.getName(api, 'openapi', {
    lower: true,
    replacement: '-',
}, true);
exports.getSpecName = getSpecName;
const generateMetadataAnnotations = (api, { pluginNames, overrideName }) => {
    var _a;
    // This annotation is required by kong-ingress-controller
    // https://github.com/Kong/kubernetes-ingress-controller/blob/main/docs/references/annotations.md#kubernetesioingressclass
    const coreAnnotations = {
        'kubernetes.io/ingress.class': 'kong',
    };
    const metadata = (_a = api.info) === null || _a === void 0 ? void 0 : _a['x-kubernetes-ingress-metadata'];
    // Only continue if metadata annotations, or plugins, or overrides exist
    if ((metadata === null || metadata === void 0 ? void 0 : metadata.annotations) || pluginNames.length || overrideName) {
        const customAnnotations = {};
        if (pluginNames.length) {
            customAnnotations['konghq.com/plugins'] = pluginNames.join(', ');
        }
        if (overrideName) {
            customAnnotations['konghq.com/override'] = overrideName;
        }
        const originalAnnotations = (metadata === null || metadata === void 0 ? void 0 : metadata.annotations) || {};
        return {
            ...originalAnnotations,
            ...customAnnotations,
            ...coreAnnotations,
        };
    }
    return coreAnnotations;
};
exports.generateMetadataAnnotations = generateMetadataAnnotations;
const generateIngressRule = (index, server, specName, paths) => {
    // Resolve serverUrl variables and update the source object so it only needs to be done once per server loop.
    server.url = variables_1.resolveUrlVariables(server.url, server.variables);
    const { hostname, pathname } = common_1.parseUrl(server.url);
    const pathsToUse = (paths === null || paths === void 0 ? void 0 : paths.length) ? paths : [''];
    const backend = {
        serviceName: exports.generateServiceName(server, specName, index),
        servicePort: exports.generateServicePort(server),
    };
    const k8sPaths = pathsToUse.map((pathToUse) => {
        const path = pathname === null ? null : exports.generateServicePath(pathname, pathToUse);
        return {
            backend,
            ...(path ? { path } : {}),
        };
    });
    const k8sIngressRule = {
        ...(hostname ? { host: hostname } : {}),
        http: {
            paths: k8sPaths,
        },
    };
    return k8sIngressRule;
};
exports.generateIngressRule = generateIngressRule;
const generateServiceName = (server, specName, index) => {
    var _a, _b, _c;
    const serviceName = (_a = server['x-kubernetes-backend']) === null || _a === void 0 ? void 0 : _a.serviceName;
    if (serviceName) {
        return serviceName;
    }
    const metadataName = (_c = (_b = server['x-kubernetes-service']) === null || _b === void 0 ? void 0 : _b.metadata) === null || _c === void 0 ? void 0 : _c.name;
    if (metadataName) {
        return metadataName;
    }
    // <ingress-name>-service-<server index>
    return `${specName}-service-${index}`;
};
exports.generateServiceName = generateServiceName;
const generateTLS = (server) => {
    if (!server) {
        return null;
    }
    const tls = server['x-kubernetes-tls'];
    if (!tls) {
        return null;
    }
    if (!Array.isArray(tls)) {
        throw new Error('x-kubernetes-tls must be an array of IngressTLS, matching the kubernetes IngressSpec resource. see https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.21/#ingressspec-v1beta1-extensions');
    }
    return tls;
};
exports.generateTLS = generateTLS;
const generateServicePort = (server) => {
    var _a, _b, _c;
    // x-kubernetes-backend.servicePort
    const backend = server['x-kubernetes-backend'];
    if (backend && typeof backend.servicePort === 'number') {
        return backend.servicePort;
    }
    const ports = ((_b = (_a = server['x-kubernetes-service']) === null || _a === void 0 ? void 0 : _a.spec) === null || _b === void 0 ? void 0 : _b.ports) || [];
    const firstPort = (_c = ports[0]) === null || _c === void 0 ? void 0 : _c.port;
    // Return 443
    if (exports.generateTLS(server)) {
        if (ports.find(p => p.port === 443)) {
            return 443;
        }
        return firstPort || 443;
    }
    return firstPort || 80;
};
exports.generateServicePort = generateServicePort;
const generateServicePath = (serverBasePath, specificPath = '') => {
    const shouldExtractPath = specificPath || (serverBasePath && serverBasePath !== '/');
    if (!shouldExtractPath) {
        return undefined;
    }
    const fullPath = url_join_1.default(serverBasePath, specificPath, specificPath ? '' : '.*');
    const pathname = variables_1.pathVariablesToWildcard(fullPath);
    return pathname;
};
exports.generateServicePath = generateServicePath;
//# sourceMappingURL=generate.js.map